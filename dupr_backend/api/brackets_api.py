# coding: utf-8

"""
    DUPR Middleware

    Application REST APIs

    The version of the OpenAPI document: v1.0 alpha
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist

from typing import Optional

from dupr_backend.models.array_wrapper_of_bracket_response import ArrayWrapperOfBracketResponse
from dupr_backend.models.array_wrapper_of_league_match_response import ArrayWrapperOfLeagueMatchResponse
from dupr_backend.models.array_wrapper_of_league_teams_response import ArrayWrapperOfLeagueTeamsResponse
from dupr_backend.models.array_wrapper_of_match_round import ArrayWrapperOfMatchRound
from dupr_backend.models.array_wrapper_of_pending_teams_response import ArrayWrapperOfPendingTeamsResponse
from dupr_backend.models.array_wrapper_of_switch_bracket_response import ArrayWrapperOfSwitchBracketResponse
from dupr_backend.models.bracket_match_request import BracketMatchRequest
from dupr_backend.models.bracket_player_switch_wait_listed_request import BracketPlayerSwitchWaitListedRequest
from dupr_backend.models.bracket_request import BracketRequest
from dupr_backend.models.bracket_search_teams_request import BracketSearchTeamsRequest
from dupr_backend.models.confirm_team_request import ConfirmTeamRequest
from dupr_backend.models.create_new_team_request import CreateNewTeamRequest
from dupr_backend.models.edit_bracket_request import EditBracketRequest
from dupr_backend.models.edit_event_team_request import EditEventTeamRequest
from dupr_backend.models.edit_match_request import EditMatchRequest
from dupr_backend.models.edit_partner_request import EditPartnerRequest
from dupr_backend.models.edit_wait_list_request import EditWaitListRequest
from dupr_backend.models.event_refund_request import EventRefundRequest
from dupr_backend.models.forfeit_match_request import ForfeitMatchRequest
from dupr_backend.models.league_match_confirm_request import LeagueMatchConfirmRequest
from dupr_backend.models.league_match_request import LeagueMatchRequest
from dupr_backend.models.match_round_req import MatchRoundReq
from dupr_backend.models.register_to_bracket_request import RegisterToBracketRequest
from dupr_backend.models.search_league_player_request import SearchLeaguePlayerRequest
from dupr_backend.models.search_unmatched_players_request import SearchUnmatchedPlayersRequest
from dupr_backend.models.single_wrapper_of_bracket_club_role_response import SingleWrapperOfBracketClubRoleResponse
from dupr_backend.models.single_wrapper_of_bracket_details_response import SingleWrapperOfBracketDetailsResponse
from dupr_backend.models.single_wrapper_of_bracket_response import SingleWrapperOfBracketResponse
from dupr_backend.models.single_wrapper_of_download_s3_response import SingleWrapperOfDownloadS3Response
from dupr_backend.models.single_wrapper_of_join_league_response import SingleWrapperOfJoinLeagueResponse
from dupr_backend.models.single_wrapper_of_league_response import SingleWrapperOfLeagueResponse
from dupr_backend.models.single_wrapper_of_page_of_bracket_response import SingleWrapperOfPageOfBracketResponse
from dupr_backend.models.single_wrapper_of_page_of_league_match_response import SingleWrapperOfPageOfLeagueMatchResponse
from dupr_backend.models.single_wrapper_of_page_of_league_standing_response import SingleWrapperOfPageOfLeagueStandingResponse
from dupr_backend.models.single_wrapper_of_page_of_league_teams_response import SingleWrapperOfPageOfLeagueTeamsResponse
from dupr_backend.models.single_wrapper_of_page_of_player_payment_response import SingleWrapperOfPageOfPlayerPaymentResponse
from dupr_backend.models.single_wrapper_of_page_of_player_response import SingleWrapperOfPageOfPlayerResponse
from dupr_backend.models.single_wrapper_of_registration_response import SingleWrapperOfRegistrationResponse
from dupr_backend.models.single_wrapper_of_session_response import SingleWrapperOfSessionResponse
from dupr_backend.models.single_wrapper_of_unit import SingleWrapperOfUnit
from dupr_backend.models.substitute_player_request import SubstitutePlayerRequest
from dupr_backend.models.switch_bracket_request import SwitchBracketRequest
from dupr_backend.models.switch_team_request import SwitchTeamRequest
from dupr_backend.models.user_club_role_request import UserClubRoleRequest
from dupr_backend.models.user_matches_request import UserMatchesRequest
from dupr_backend.models.withdraw_player_request import WithdrawPlayerRequest
from dupr_backend.models.wrapper import Wrapper

from dupr_backend.api_client import ApiClient
from dupr_backend.api_response import ApiResponse
from dupr_backend.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class BracketsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def add_match_score_by_director_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[LeagueMatchRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """addMatchScoreByDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_match_score_by_director_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: LeagueMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the add_match_score_by_director_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.add_match_score_by_director_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def add_match_score_by_director_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[LeagueMatchRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """addMatchScoreByDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_match_score_by_director_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: LeagueMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_match_score_by_director_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/match/{version}/save', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def add_match_score_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[LeagueMatchRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """addMatchScore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_match_score_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: LeagueMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the add_match_score_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.add_match_score_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def add_match_score_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[LeagueMatchRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """addMatchScore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_match_score_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: LeagueMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_match_score_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/match/{version}/save', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def confirm_match_director_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[LeagueMatchConfirmRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """confirmMatchDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_match_director_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: LeagueMatchConfirmRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the confirm_match_director_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.confirm_match_director_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def confirm_match_director_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[LeagueMatchConfirmRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """confirmMatchDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_match_director_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: LeagueMatchConfirmRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method confirm_match_director_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/match/{version}/confirm', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def confirm_match_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[LeagueMatchConfirmRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """confirmMatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_match_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: LeagueMatchConfirmRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the confirm_match_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.confirm_match_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def confirm_match_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[LeagueMatchConfirmRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """confirmMatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_match_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: LeagueMatchConfirmRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method confirm_match_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/match/{version}/confirm', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def confirm_team_by_director_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], confirm_team_request : Annotated[ConfirmTeamRequest, Field(..., description="confirmTeamRequest")], **kwargs) -> Wrapper:  # noqa: E501
        """confirmTeamByDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_team_by_director_using_post(authorization, version, confirm_team_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param confirm_team_request: confirmTeamRequest (required)
        :type confirm_team_request: ConfirmTeamRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the confirm_team_by_director_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.confirm_team_by_director_using_post_with_http_info(authorization, version, confirm_team_request, **kwargs)  # noqa: E501

    @validate_arguments
    def confirm_team_by_director_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], confirm_team_request : Annotated[ConfirmTeamRequest, Field(..., description="confirmTeamRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """confirmTeamByDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.confirm_team_by_director_using_post_with_http_info(authorization, version, confirm_team_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param confirm_team_request: confirmTeamRequest (required)
        :type confirm_team_request: ConfirmTeamRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'confirm_team_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method confirm_team_by_director_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['confirm_team_request'] is not None:
            _body_params = _params['confirm_team_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/teams/{version}/confirm', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_league_using_delete(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], league_id : Annotated[StrictInt, Field(..., description="leagueId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> Wrapper:  # noqa: E501
        """deleteLeague  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_league_using_delete(authorization, bracket_id, league_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param league_id: leagueId (required)
        :type league_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the delete_league_using_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.delete_league_using_delete_with_http_info(authorization, bracket_id, league_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_league_using_delete_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], league_id : Annotated[StrictInt, Field(..., description="leagueId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """deleteLeague  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_league_using_delete_with_http_info(authorization, bracket_id, league_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param league_id: leagueId (required)
        :type league_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'league_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_league_using_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['league_id']:
            _path_params['leagueId'] = _params['league_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/{leagueId}/{bracketId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def edit_bracket_status_using_put(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], club_id : Annotated[StrictInt, Field(..., description="clubId")], league_id : Annotated[StrictInt, Field(..., description="leagueId")], status : Annotated[StrictStr, Field(..., description="status")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> SingleWrapperOfUnit:  # noqa: E501
        """editBracketStatus  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_bracket_status_using_put(authorization, bracket_id, club_id, league_id, status, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param club_id: clubId (required)
        :type club_id: int
        :param league_id: leagueId (required)
        :type league_id: int
        :param status: status (required)
        :type status: str
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfUnit
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the edit_bracket_status_using_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.edit_bracket_status_using_put_with_http_info(authorization, bracket_id, club_id, league_id, status, version, **kwargs)  # noqa: E501

    @validate_arguments
    def edit_bracket_status_using_put_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], club_id : Annotated[StrictInt, Field(..., description="clubId")], league_id : Annotated[StrictInt, Field(..., description="leagueId")], status : Annotated[StrictStr, Field(..., description="status")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """editBracketStatus  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_bracket_status_using_put_with_http_info(authorization, bracket_id, club_id, league_id, status, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param club_id: clubId (required)
        :type club_id: int
        :param league_id: leagueId (required)
        :type league_id: int
        :param status: status (required)
        :type status: str
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfUnit, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'club_id',
            'league_id',
            'status',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_bracket_status_using_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('bracket_id') is not None:  # noqa: E501
            _query_params.append(('bracketId', _params['bracket_id']))

        if _params.get('club_id') is not None:  # noqa: E501
            _query_params.append(('clubId', _params['club_id']))

        if _params.get('league_id') is not None:  # noqa: E501
            _query_params.append(('leagueId', _params['league_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfUnit",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/{version}/edit/bracket_status', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def edit_bracket_using_put(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EditBracketRequest, Field(..., description="request")], **kwargs) -> SingleWrapperOfLeagueResponse:  # noqa: E501
        """editBracket  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_bracket_using_put(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EditBracketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfLeagueResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the edit_bracket_using_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.edit_bracket_using_put_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def edit_bracket_using_put_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EditBracketRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """editBracket  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_bracket_using_put_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EditBracketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfLeagueResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_bracket_using_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfLeagueResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/edit', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def edit_confirmed_matches_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], edit_match_request : Annotated[EditMatchRequest, Field(..., description="editMatchRequest")], **kwargs) -> Wrapper:  # noqa: E501
        """editConfirmedMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_confirmed_matches_using_post(authorization, version, edit_match_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param edit_match_request: editMatchRequest (required)
        :type edit_match_request: EditMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the edit_confirmed_matches_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.edit_confirmed_matches_using_post_with_http_info(authorization, version, edit_match_request, **kwargs)  # noqa: E501

    @validate_arguments
    def edit_confirmed_matches_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], edit_match_request : Annotated[EditMatchRequest, Field(..., description="editMatchRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """editConfirmedMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_confirmed_matches_using_post_with_http_info(authorization, version, edit_match_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param edit_match_request: editMatchRequest (required)
        :type edit_match_request: EditMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'edit_match_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_confirmed_matches_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['edit_match_request'] is not None:
            _body_params = _params['edit_match_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/confirm/match/{version}/edit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def edit_match_score_by_director_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EditMatchRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """editMatchScoreByDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_match_score_by_director_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EditMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the edit_match_score_by_director_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.edit_match_score_by_director_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def edit_match_score_by_director_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EditMatchRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """editMatchScoreByDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_match_score_by_director_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EditMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_match_score_by_director_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/match/{version}/edit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def edit_match_score_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EditMatchRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """editMatchScore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_match_score_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EditMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the edit_match_score_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.edit_match_score_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def edit_match_score_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EditMatchRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """editMatchScore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_match_score_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EditMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_match_score_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/match/{version}/edit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def edit_partner_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EditPartnerRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """editPartner  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_partner_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EditPartnerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the edit_partner_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.edit_partner_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def edit_partner_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EditPartnerRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """editPartner  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_partner_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EditPartnerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_partner_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/partner/{version}/edit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def edit_player_wait_list_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], edit_wait_list_request : Annotated[conlist(EditWaitListRequest), Field(..., description="editWaitListRequest")], **kwargs) -> Wrapper:  # noqa: E501
        """editPlayerWaitList  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_player_wait_list_using_post(authorization, version, edit_wait_list_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param edit_wait_list_request: editWaitListRequest (required)
        :type edit_wait_list_request: List[EditWaitListRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the edit_player_wait_list_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.edit_player_wait_list_using_post_with_http_info(authorization, version, edit_wait_list_request, **kwargs)  # noqa: E501

    @validate_arguments
    def edit_player_wait_list_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], edit_wait_list_request : Annotated[conlist(EditWaitListRequest), Field(..., description="editWaitListRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """editPlayerWaitList  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_player_wait_list_using_post_with_http_info(authorization, version, edit_wait_list_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param edit_wait_list_request: editWaitListRequest (required)
        :type edit_wait_list_request: List[EditWaitListRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'edit_wait_list_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_player_wait_list_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['edit_wait_list_request'] is not None:
            _body_params = _params['edit_wait_list_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/waitlist/{version}/edit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def edit_teams_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], edit_event_team_request : Annotated[EditEventTeamRequest, Field(..., description="editEventTeamRequest")], **kwargs) -> Wrapper:  # noqa: E501
        """editTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_teams_using_post(authorization, version, edit_event_team_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param edit_event_team_request: editEventTeamRequest (required)
        :type edit_event_team_request: EditEventTeamRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the edit_teams_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.edit_teams_using_post_with_http_info(authorization, version, edit_event_team_request, **kwargs)  # noqa: E501

    @validate_arguments
    def edit_teams_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], edit_event_team_request : Annotated[EditEventTeamRequest, Field(..., description="editEventTeamRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """editTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.edit_teams_using_post_with_http_info(authorization, version, edit_event_team_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param edit_event_team_request: editEventTeamRequest (required)
        :type edit_event_team_request: EditEventTeamRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'edit_event_team_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_teams_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['edit_event_team_request'] is not None:
            _body_params = _params['edit_event_team_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/{bracketId}/teams/{version}/edit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def end_league_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], league_id : Annotated[StrictInt, Field(..., description="leagueId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> Wrapper:  # noqa: E501
        """endLeague  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.end_league_using_get(authorization, bracket_id, league_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param league_id: leagueId (required)
        :type league_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the end_league_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.end_league_using_get_with_http_info(authorization, bracket_id, league_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def end_league_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], league_id : Annotated[StrictInt, Field(..., description="leagueId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """endLeague  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.end_league_using_get_with_http_info(authorization, bracket_id, league_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param league_id: leagueId (required)
        :type league_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'league_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method end_league_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['league_id']:
            _path_params['leagueId'] = _params['league_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{leagueId}/{bracketId}/{version}/end', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def export_bracket_participants_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> SingleWrapperOfDownloadS3Response:  # noqa: E501
        """exportBracketParticipants  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_bracket_participants_using_get(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfDownloadS3Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the export_bracket_participants_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.export_bracket_participants_using_get_with_http_info(authorization, bracket_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def export_bracket_participants_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """exportBracketParticipants  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_bracket_participants_using_get_with_http_info(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfDownloadS3Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_bracket_participants_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfDownloadS3Response",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/{bracketId}/participant/{version}/export', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forfeit_match_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[ForfeitMatchRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """forfeitMatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forfeit_match_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: ForfeitMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the forfeit_match_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.forfeit_match_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def forfeit_match_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[ForfeitMatchRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """forfeitMatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forfeit_match_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: ForfeitMatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forfeit_match_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/match/{version}/forfeit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_all_bracket_matches_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ArrayWrapperOfLeagueMatchResponse:  # noqa: E501
        """getAllBracketMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_bracket_matches_using_get(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfLeagueMatchResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_all_bracket_matches_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_all_bracket_matches_using_get_with_http_info(authorization, bracket_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_all_bracket_matches_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getAllBracketMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_bracket_matches_using_get_with_http_info(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfLeagueMatchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_bracket_matches_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfLeagueMatchResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{bracketId}/match/{version}/all', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_all_event_players_using_post(self, authorization : StrictStr, limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], search_league_player_request : Annotated[SearchLeaguePlayerRequest, Field(..., description="searchLeaguePlayerRequest")], **kwargs) -> SingleWrapperOfPageOfPlayerPaymentResponse:  # noqa: E501
        """getAllEventPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_event_players_using_post(authorization, limit, offset, version, search_league_player_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param search_league_player_request: searchLeaguePlayerRequest (required)
        :type search_league_player_request: SearchLeaguePlayerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfPlayerPaymentResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_all_event_players_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_all_event_players_using_post_with_http_info(authorization, limit, offset, version, search_league_player_request, **kwargs)  # noqa: E501

    @validate_arguments
    def get_all_event_players_using_post_with_http_info(self, authorization : StrictStr, limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], search_league_player_request : Annotated[SearchLeaguePlayerRequest, Field(..., description="searchLeaguePlayerRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """getAllEventPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_event_players_using_post_with_http_info(authorization, limit, offset, version, search_league_player_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param search_league_player_request: searchLeaguePlayerRequest (required)
        :type search_league_player_request: SearchLeaguePlayerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfPlayerPaymentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'limit',
            'offset',
            'version',
            'search_league_player_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_event_players_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['search_league_player_request'] is not None:
            _body_params = _params['search_league_player_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfPlayerPaymentResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/participant/{version}/all', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_by_id_using_get(self, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], authorization : Optional[StrictStr] = None, **kwargs) -> SingleWrapperOfBracketResponse:  # noqa: E501
        """getBracketById  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_by_id_using_get(bracket_id, version, authorization, async_req=True)
        >>> result = thread.get()

        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param authorization:
        :type authorization: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfBracketResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_by_id_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_by_id_using_get_with_http_info(bracket_id, version, authorization, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_by_id_using_get_with_http_info(self, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], authorization : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketById  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_by_id_using_get_with_http_info(bracket_id, version, authorization, async_req=True)
        >>> result = thread.get()

        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param authorization:
        :type authorization: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfBracketResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'bracket_id',
            'version',
            'authorization'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_by_id_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfBracketResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/{bracketId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_details_teams_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> SingleWrapperOfBracketDetailsResponse:  # noqa: E501
        """getBracketDetailsTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_details_teams_using_get(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfBracketDetailsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_details_teams_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_details_teams_using_get_with_http_info(authorization, bracket_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_details_teams_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketDetailsTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_details_teams_using_get_with_http_info(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfBracketDetailsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_details_teams_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfBracketDetailsResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{bracketId}/{version}/read', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_match_queue_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], limit : Annotated[Optional[StrictInt], Field(description="limit")] = None, offset : Annotated[Optional[StrictInt], Field(description="offset")] = None, **kwargs) -> SingleWrapperOfPageOfLeagueMatchResponse:  # noqa: E501
        """getBracketMatchQueue  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_match_queue_using_get(authorization, bracket_id, version, limit, offset, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param limit: limit
        :type limit: int
        :param offset: offset
        :type offset: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueMatchResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_match_queue_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_match_queue_using_get_with_http_info(authorization, bracket_id, version, limit, offset, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_match_queue_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], limit : Annotated[Optional[StrictInt], Field(description="limit")] = None, offset : Annotated[Optional[StrictInt], Field(description="offset")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketMatchQueue  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_match_queue_using_get_with_http_info(authorization, bracket_id, version, limit, offset, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param limit: limit
        :type limit: int
        :param offset: offset
        :type offset: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueMatchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version',
            'limit',
            'offset'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_match_queue_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueMatchResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{bracketId}/queue/{version}/all', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_matches_post_using_post(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], bracket_match_request : Annotated[BracketMatchRequest, Field(..., description="bracketMatchRequest")], limit : Annotated[Optional[StrictInt], Field(description="limit")] = None, offset : Annotated[Optional[StrictInt], Field(description="offset")] = None, round : Annotated[Optional[StrictInt], Field(description="round")] = None, **kwargs) -> SingleWrapperOfPageOfLeagueMatchResponse:  # noqa: E501
        """getBracketMatchesPost  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_matches_post_using_post(authorization, bracket_id, version, bracket_match_request, limit, offset, round, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param bracket_match_request: bracketMatchRequest (required)
        :type bracket_match_request: BracketMatchRequest
        :param limit: limit
        :type limit: int
        :param offset: offset
        :type offset: int
        :param round: round
        :type round: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueMatchResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_matches_post_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_matches_post_using_post_with_http_info(authorization, bracket_id, version, bracket_match_request, limit, offset, round, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_matches_post_using_post_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], bracket_match_request : Annotated[BracketMatchRequest, Field(..., description="bracketMatchRequest")], limit : Annotated[Optional[StrictInt], Field(description="limit")] = None, offset : Annotated[Optional[StrictInt], Field(description="offset")] = None, round : Annotated[Optional[StrictInt], Field(description="round")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketMatchesPost  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_matches_post_using_post_with_http_info(authorization, bracket_id, version, bracket_match_request, limit, offset, round, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param bracket_match_request: bracketMatchRequest (required)
        :type bracket_match_request: BracketMatchRequest
        :param limit: limit
        :type limit: int
        :param offset: offset
        :type offset: int
        :param round: round
        :type round: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueMatchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version',
            'bracket_match_request',
            'limit',
            'offset',
            'round'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_matches_post_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('bracket_id') is not None:  # noqa: E501
            _query_params.append(('bracketId', _params['bracket_id']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('round') is not None:  # noqa: E501
            _query_params.append(('round', _params['round']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['bracket_match_request'] is not None:
            _body_params = _params['bracket_match_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueMatchResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/match/{version}/history', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_matches_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], limit : Annotated[Optional[StrictInt], Field(description="limit")] = None, offset : Annotated[Optional[StrictInt], Field(description="offset")] = None, round : Annotated[Optional[StrictInt], Field(description="round")] = None, tags : Annotated[Optional[StrictStr], Field(description="tags")] = None, **kwargs) -> SingleWrapperOfPageOfLeagueMatchResponse:  # noqa: E501
        """getBracketMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_matches_using_get(authorization, bracket_id, version, limit, offset, round, tags, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param limit: limit
        :type limit: int
        :param offset: offset
        :type offset: int
        :param round: round
        :type round: int
        :param tags: tags
        :type tags: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueMatchResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_matches_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_matches_using_get_with_http_info(authorization, bracket_id, version, limit, offset, round, tags, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_matches_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], limit : Annotated[Optional[StrictInt], Field(description="limit")] = None, offset : Annotated[Optional[StrictInt], Field(description="offset")] = None, round : Annotated[Optional[StrictInt], Field(description="round")] = None, tags : Annotated[Optional[StrictStr], Field(description="tags")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_matches_using_get_with_http_info(authorization, bracket_id, version, limit, offset, round, tags, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param limit: limit
        :type limit: int
        :param offset: offset
        :type offset: int
        :param round: round
        :type round: int
        :param tags: tags
        :type tags: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueMatchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version',
            'limit',
            'offset',
            'round',
            'tags'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_matches_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('bracket_id') is not None:  # noqa: E501
            _query_params.append(('bracketId', _params['bracket_id']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('round') is not None:  # noqa: E501
            _query_params.append(('round', _params['round']))

        if _params.get('tags') is not None:  # noqa: E501
            _query_params.append(('tags', _params['tags']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueMatchResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/match/{version}/history', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_players_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], query : Annotated[Optional[StrictStr], Field(description="query")] = None, **kwargs) -> SingleWrapperOfPageOfPlayerResponse:  # noqa: E501
        """getBracketPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_players_using_get(authorization, bracket_id, limit, offset, version, query, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param query: query
        :type query: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfPlayerResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_players_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_players_using_get_with_http_info(authorization, bracket_id, limit, offset, version, query, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_players_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], query : Annotated[Optional[StrictStr], Field(description="query")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_players_using_get_with_http_info(authorization, bracket_id, limit, offset, version, query, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param query: query
        :type query: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfPlayerResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'limit',
            'offset',
            'version',
            'query'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_players_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('query') is not None:  # noqa: E501
            _query_params.append(('query', _params['query']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfPlayerResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{bracketId}/participant/{version}/all', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_players_using_post(self, authorization : StrictStr, limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], search_league_player_request : Annotated[SearchLeaguePlayerRequest, Field(..., description="searchLeaguePlayerRequest")], **kwargs) -> SingleWrapperOfPageOfPlayerResponse:  # noqa: E501
        """getBracketPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_players_using_post(authorization, limit, offset, version, search_league_player_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param search_league_player_request: searchLeaguePlayerRequest (required)
        :type search_league_player_request: SearchLeaguePlayerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfPlayerResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_players_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_players_using_post_with_http_info(authorization, limit, offset, version, search_league_player_request, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_players_using_post_with_http_info(self, authorization : StrictStr, limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], search_league_player_request : Annotated[SearchLeaguePlayerRequest, Field(..., description="searchLeaguePlayerRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_players_using_post_with_http_info(authorization, limit, offset, version, search_league_player_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param search_league_player_request: searchLeaguePlayerRequest (required)
        :type search_league_player_request: SearchLeaguePlayerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfPlayerResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'limit',
            'offset',
            'version',
            'search_league_player_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_players_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['search_league_player_request'] is not None:
            _body_params = _params['search_league_player_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfPlayerResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/participant/{version}/all', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_standing_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], limit : Annotated[StrictInt, Field(..., description="limit")], version : Annotated[StrictStr, Field(..., description="version")], offset : Annotated[Optional[StrictInt], Field(description="offset")] = None, round : Annotated[Optional[StrictInt], Field(description="round")] = None, **kwargs) -> SingleWrapperOfPageOfLeagueStandingResponse:  # noqa: E501
        """getBracketStanding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_standing_using_get(authorization, bracket_id, limit, version, offset, round, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param limit: limit (required)
        :type limit: int
        :param version: version (required)
        :type version: str
        :param offset: offset
        :type offset: int
        :param round: round
        :type round: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueStandingResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_standing_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_standing_using_get_with_http_info(authorization, bracket_id, limit, version, offset, round, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_standing_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], limit : Annotated[StrictInt, Field(..., description="limit")], version : Annotated[StrictStr, Field(..., description="version")], offset : Annotated[Optional[StrictInt], Field(description="offset")] = None, round : Annotated[Optional[StrictInt], Field(description="round")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketStanding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_standing_using_get_with_http_info(authorization, bracket_id, limit, version, offset, round, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param limit: limit (required)
        :type limit: int
        :param version: version (required)
        :type version: str
        :param offset: offset
        :type offset: int
        :param round: round
        :type round: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueStandingResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'limit',
            'version',
            'offset',
            'round'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_standing_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('bracket_id') is not None:  # noqa: E501
            _query_params.append(('bracketId', _params['bracket_id']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('round') is not None:  # noqa: E501
            _query_params.append(('round', _params['round']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueStandingResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/standing', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_teams_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], format : Annotated[StrictStr, Field(..., description="format")], limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> SingleWrapperOfPageOfLeagueTeamsResponse:  # noqa: E501
        """getBracketTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_teams_using_get(authorization, bracket_id, format, limit, offset, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param format: format (required)
        :type format: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueTeamsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_teams_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_teams_using_get_with_http_info(authorization, bracket_id, format, limit, offset, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_teams_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], format : Annotated[StrictStr, Field(..., description="format")], limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_teams_using_get_with_http_info(authorization, bracket_id, format, limit, offset, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param format: format (required)
        :type format: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueTeamsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'format',
            'limit',
            'offset',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_teams_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueTeamsResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{bracketId}/{version}/teams', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_teams_using_post(self, authorization : StrictStr, format : Annotated[StrictStr, Field(..., description="format")], version : Annotated[StrictStr, Field(..., description="version")], bracket_search_teams_request : Annotated[BracketSearchTeamsRequest, Field(..., description="bracketSearchTeamsRequest")], **kwargs) -> SingleWrapperOfPageOfLeagueTeamsResponse:  # noqa: E501
        """getBracketTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_teams_using_post(authorization, format, version, bracket_search_teams_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param format: format (required)
        :type format: str
        :param version: version (required)
        :type version: str
        :param bracket_search_teams_request: bracketSearchTeamsRequest (required)
        :type bracket_search_teams_request: BracketSearchTeamsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueTeamsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_teams_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_teams_using_post_with_http_info(authorization, format, version, bracket_search_teams_request, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_teams_using_post_with_http_info(self, authorization : StrictStr, format : Annotated[StrictStr, Field(..., description="format")], version : Annotated[StrictStr, Field(..., description="version")], bracket_search_teams_request : Annotated[BracketSearchTeamsRequest, Field(..., description="bracketSearchTeamsRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_teams_using_post_with_http_info(authorization, format, version, bracket_search_teams_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param format: format (required)
        :type format: str
        :param version: version (required)
        :type version: str
        :param bracket_search_teams_request: bracketSearchTeamsRequest (required)
        :type bracket_search_teams_request: BracketSearchTeamsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueTeamsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'format',
            'version',
            'bracket_search_teams_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_teams_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['bracket_search_teams_request'] is not None:
            _body_params = _params['bracket_search_teams_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueTeamsResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/teams', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_bracket_waitlisted_teams_using_post(self, authorization : StrictStr, format : Annotated[StrictStr, Field(..., description="format")], version : Annotated[StrictStr, Field(..., description="version")], bracket_search_teams_request : Annotated[BracketSearchTeamsRequest, Field(..., description="bracketSearchTeamsRequest")], **kwargs) -> SingleWrapperOfPageOfLeagueTeamsResponse:  # noqa: E501
        """getBracketWaitlistedTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_waitlisted_teams_using_post(authorization, format, version, bracket_search_teams_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param format: format (required)
        :type format: str
        :param version: version (required)
        :type version: str
        :param bracket_search_teams_request: bracketSearchTeamsRequest (required)
        :type bracket_search_teams_request: BracketSearchTeamsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueTeamsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_bracket_waitlisted_teams_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_bracket_waitlisted_teams_using_post_with_http_info(authorization, format, version, bracket_search_teams_request, **kwargs)  # noqa: E501

    @validate_arguments
    def get_bracket_waitlisted_teams_using_post_with_http_info(self, authorization : StrictStr, format : Annotated[StrictStr, Field(..., description="format")], version : Annotated[StrictStr, Field(..., description="version")], bracket_search_teams_request : Annotated[BracketSearchTeamsRequest, Field(..., description="bracketSearchTeamsRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """getBracketWaitlistedTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bracket_waitlisted_teams_using_post_with_http_info(authorization, format, version, bracket_search_teams_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param format: format (required)
        :type format: str
        :param version: version (required)
        :type version: str
        :param bracket_search_teams_request: bracketSearchTeamsRequest (required)
        :type bracket_search_teams_request: BracketSearchTeamsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueTeamsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'format',
            'version',
            'bracket_search_teams_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bracket_waitlisted_teams_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['bracket_search_teams_request'] is not None:
            _body_params = _params['bracket_search_teams_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueTeamsResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/waitlist/teams', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_director_bracket_teams_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], format : Annotated[StrictStr, Field(..., description="format")], limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> SingleWrapperOfPageOfLeagueTeamsResponse:  # noqa: E501
        """getDirectorBracketTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_director_bracket_teams_using_get(authorization, bracket_id, format, limit, offset, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param format: format (required)
        :type format: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueTeamsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_director_bracket_teams_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_director_bracket_teams_using_get_with_http_info(authorization, bracket_id, format, limit, offset, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_director_bracket_teams_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], format : Annotated[StrictStr, Field(..., description="format")], limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getDirectorBracketTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_director_bracket_teams_using_get_with_http_info(authorization, bracket_id, format, limit, offset, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param format: format (required)
        :type format: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueTeamsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'format',
            'limit',
            'offset',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_director_bracket_teams_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueTeamsResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/{bracketId}/{version}/teams', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_pending_confirmation_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ArrayWrapperOfLeagueTeamsResponse:  # noqa: E501
        """getPendingConfirmation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_pending_confirmation_using_get(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfLeagueTeamsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_pending_confirmation_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_pending_confirmation_using_get_with_http_info(authorization, bracket_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_pending_confirmation_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getPendingConfirmation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_pending_confirmation_using_get_with_http_info(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfLeagueTeamsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pending_confirmation_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('bracket_id') is not None:  # noqa: E501
            _query_params.append(('bracketId', _params['bracket_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfLeagueTeamsResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/teams/{version}/pending', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_pending_teams_to_replace_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ArrayWrapperOfPendingTeamsResponse:  # noqa: E501
        """getPendingTeamsToReplace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_pending_teams_to_replace_using_get(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfPendingTeamsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_pending_teams_to_replace_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_pending_teams_to_replace_using_get_with_http_info(authorization, bracket_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_pending_teams_to_replace_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getPendingTeamsToReplace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_pending_teams_to_replace_using_get_with_http_info(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfPendingTeamsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pending_teams_to_replace_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfPendingTeamsResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{bracketId}/director/teams/pending/{version}/all', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_registration_details_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> SingleWrapperOfRegistrationResponse:  # noqa: E501
        """getRegistrationDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_registration_details_using_get(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfRegistrationResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_registration_details_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_registration_details_using_get_with_http_info(authorization, bracket_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_registration_details_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getRegistrationDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_registration_details_using_get_with_http_info(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfRegistrationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_registration_details_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfRegistrationResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{bracketId}/participant/{version}/details', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_unmatched_players_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], query : Annotated[Optional[StrictStr], Field(description="query")] = None, **kwargs) -> SingleWrapperOfPageOfPlayerResponse:  # noqa: E501
        """getUnmatchedPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_unmatched_players_using_get(authorization, bracket_id, limit, offset, version, query, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param query: query
        :type query: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfPlayerResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_unmatched_players_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_unmatched_players_using_get_with_http_info(authorization, bracket_id, limit, offset, version, query, **kwargs)  # noqa: E501

    @validate_arguments
    def get_unmatched_players_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], query : Annotated[Optional[StrictStr], Field(description="query")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """getUnmatchedPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_unmatched_players_using_get_with_http_info(authorization, bracket_id, limit, offset, version, query, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param query: query
        :type query: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfPlayerResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'limit',
            'offset',
            'version',
            'query'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unmatched_players_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('query') is not None:  # noqa: E501
            _query_params.append(('query', _params['query']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfPlayerResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{bracketId}/participant/unmatched/{version}/all', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_unmatched_players_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], search_unmatched_players_request : Annotated[SearchUnmatchedPlayersRequest, Field(..., description="searchUnmatchedPlayersRequest")], **kwargs) -> SingleWrapperOfPageOfPlayerResponse:  # noqa: E501
        """getUnmatchedPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_unmatched_players_using_post(authorization, version, search_unmatched_players_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param search_unmatched_players_request: searchUnmatchedPlayersRequest (required)
        :type search_unmatched_players_request: SearchUnmatchedPlayersRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfPlayerResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_unmatched_players_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_unmatched_players_using_post_with_http_info(authorization, version, search_unmatched_players_request, **kwargs)  # noqa: E501

    @validate_arguments
    def get_unmatched_players_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], search_unmatched_players_request : Annotated[SearchUnmatchedPlayersRequest, Field(..., description="searchUnmatchedPlayersRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """getUnmatchedPlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_unmatched_players_using_post_with_http_info(authorization, version, search_unmatched_players_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param search_unmatched_players_request: searchUnmatchedPlayersRequest (required)
        :type search_unmatched_players_request: SearchUnmatchedPlayersRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfPlayerResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'search_unmatched_players_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unmatched_players_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['search_unmatched_players_request'] is not None:
            _body_params = _params['search_unmatched_players_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfPlayerResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/participant/unmatched/{version}/all', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_user_brackets_using_get(self, authorization : StrictStr, limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], status : Annotated[Optional[StrictStr], Field(description="status")] = None, **kwargs) -> SingleWrapperOfPageOfBracketResponse:  # noqa: E501
        """getUserBrackets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_brackets_using_get(authorization, limit, offset, version, status, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param status: status
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfBracketResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_user_brackets_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_user_brackets_using_get_with_http_info(authorization, limit, offset, version, status, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_brackets_using_get_with_http_info(self, authorization : StrictStr, limit : Annotated[StrictInt, Field(..., description="limit")], offset : Annotated[StrictInt, Field(..., description="offset")], version : Annotated[StrictStr, Field(..., description="version")], status : Annotated[Optional[StrictStr], Field(description="status")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """getUserBrackets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_brackets_using_get_with_http_info(authorization, limit, offset, version, status, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param limit: limit (required)
        :type limit: int
        :param offset: offset (required)
        :type offset: int
        :param version: version (required)
        :type version: str
        :param status: status
        :type status: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfBracketResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'limit',
            'offset',
            'version',
            'status'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_brackets_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfBracketResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/all', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_user_club_role_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[UserClubRoleRequest, Field(..., description="request")], **kwargs) -> SingleWrapperOfBracketClubRoleResponse:  # noqa: E501
        """getUserClubRole  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_club_role_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: UserClubRoleRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfBracketClubRoleResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_user_club_role_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_user_club_role_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_club_role_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[UserClubRoleRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """getUserClubRole  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_club_role_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: UserClubRoleRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfBracketClubRoleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_club_role_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfBracketClubRoleResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/club/roles/{version}/details', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_user_event_brackets_using_get(self, authorization : StrictStr, league_id : Annotated[StrictInt, Field(..., description="leagueId")], user_id : Annotated[StrictInt, Field(..., description="userId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ArrayWrapperOfBracketResponse:  # noqa: E501
        """getUserEventBrackets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_event_brackets_using_get(authorization, league_id, user_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param league_id: leagueId (required)
        :type league_id: int
        :param user_id: userId (required)
        :type user_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfBracketResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_user_event_brackets_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_user_event_brackets_using_get_with_http_info(authorization, league_id, user_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_event_brackets_using_get_with_http_info(self, authorization : StrictStr, league_id : Annotated[StrictInt, Field(..., description="leagueId")], user_id : Annotated[StrictInt, Field(..., description="userId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getUserEventBrackets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_event_brackets_using_get_with_http_info(authorization, league_id, user_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param league_id: leagueId (required)
        :type league_id: int
        :param user_id: userId (required)
        :type user_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfBracketResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'league_id',
            'user_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_event_brackets_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['league_id']:
            _path_params['leagueId'] = _params['league_id']

        if _params['user_id']:
            _path_params['userId'] = _params['user_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfBracketResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/{leagueId}/{userId}/{version}/all', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_user_matches_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], user_matches_request : Annotated[UserMatchesRequest, Field(..., description="userMatchesRequest")], **kwargs) -> SingleWrapperOfPageOfLeagueMatchResponse:  # noqa: E501
        """getUserMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_matches_using_post(authorization, version, user_matches_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param user_matches_request: userMatchesRequest (required)
        :type user_matches_request: UserMatchesRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfPageOfLeagueMatchResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_user_matches_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_user_matches_using_post_with_http_info(authorization, version, user_matches_request, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_matches_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], user_matches_request : Annotated[UserMatchesRequest, Field(..., description="userMatchesRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """getUserMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_matches_using_post_with_http_info(authorization, version, user_matches_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param user_matches_request: userMatchesRequest (required)
        :type user_matches_request: UserMatchesRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfPageOfLeagueMatchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'user_matches_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_matches_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['user_matches_request'] is not None:
            _body_params = _params['user_matches_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfPageOfLeagueMatchResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/match/participant/{version}/history', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_valid_user_bracket_id_using_get(self, authorization : StrictStr, league_id : Annotated[StrictInt, Field(..., description="leagueId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ArrayWrapperOfBracketResponse:  # noqa: E501
        """getValidUserBracketId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_valid_user_bracket_id_using_get(authorization, league_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param league_id: leagueId (required)
        :type league_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfBracketResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_valid_user_bracket_id_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_valid_user_bracket_id_using_get_with_http_info(authorization, league_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_valid_user_bracket_id_using_get_with_http_info(self, authorization : StrictStr, league_id : Annotated[StrictInt, Field(..., description="leagueId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getValidUserBracketId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_valid_user_bracket_id_using_get_with_http_info(authorization, league_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param league_id: leagueId (required)
        :type league_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfBracketResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'league_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_valid_user_bracket_id_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['league_id']:
            _path_params['leagueId'] = _params['league_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfBracketResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/valid/{version}/{leagueId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_waterfall_matches_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ArrayWrapperOfLeagueMatchResponse:  # noqa: E501
        """getWaterfallMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_waterfall_matches_using_get(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfLeagueMatchResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_waterfall_matches_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_waterfall_matches_using_get_with_http_info(authorization, bracket_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_waterfall_matches_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """getWaterfallMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_waterfall_matches_using_get_with_http_info(authorization, bracket_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfLeagueMatchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_waterfall_matches_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bracket_id']:
            _path_params['bracketId'] = _params['bracket_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfLeagueMatchResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/match/{bracketId}/{version}/structure', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def player_withdraw_by_director_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], withdraw_player_request : Annotated[WithdrawPlayerRequest, Field(..., description="withdrawPlayerRequest")], **kwargs) -> Wrapper:  # noqa: E501
        """playerWithdrawByDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.player_withdraw_by_director_using_post(authorization, version, withdraw_player_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param withdraw_player_request: withdrawPlayerRequest (required)
        :type withdraw_player_request: WithdrawPlayerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the player_withdraw_by_director_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.player_withdraw_by_director_using_post_with_http_info(authorization, version, withdraw_player_request, **kwargs)  # noqa: E501

    @validate_arguments
    def player_withdraw_by_director_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], withdraw_player_request : Annotated[WithdrawPlayerRequest, Field(..., description="withdrawPlayerRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """playerWithdrawByDirector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.player_withdraw_by_director_using_post_with_http_info(authorization, version, withdraw_player_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param withdraw_player_request: withdrawPlayerRequest (required)
        :type withdraw_player_request: WithdrawPlayerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'withdraw_player_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method player_withdraw_by_director_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['withdraw_player_request'] is not None:
            _body_params = _params['withdraw_player_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/{version}/withdraw', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def player_withdraw_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], withdraw_player_request : Annotated[WithdrawPlayerRequest, Field(..., description="withdrawPlayerRequest")], **kwargs) -> Wrapper:  # noqa: E501
        """playerWithdraw  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.player_withdraw_using_post(authorization, version, withdraw_player_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param withdraw_player_request: withdrawPlayerRequest (required)
        :type withdraw_player_request: WithdrawPlayerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the player_withdraw_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.player_withdraw_using_post_with_http_info(authorization, version, withdraw_player_request, **kwargs)  # noqa: E501

    @validate_arguments
    def player_withdraw_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], withdraw_player_request : Annotated[WithdrawPlayerRequest, Field(..., description="withdrawPlayerRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """playerWithdraw  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.player_withdraw_using_post_with_http_info(authorization, version, withdraw_player_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param withdraw_player_request: withdrawPlayerRequest (required)
        :type withdraw_player_request: WithdrawPlayerRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'withdraw_player_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method player_withdraw_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['withdraw_player_request'] is not None:
            _body_params = _params['withdraw_player_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/player/{version}/withdraw', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def process_refunds_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EventRefundRequest, Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """processRefunds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.process_refunds_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EventRefundRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the process_refunds_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.process_refunds_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def process_refunds_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[EventRefundRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """processRefunds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.process_refunds_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: EventRefundRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method process_refunds_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/{version}/refund', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def register_users_to_bracket_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[RegisterToBracketRequest, Field(..., description="request")], **kwargs) -> SingleWrapperOfJoinLeagueResponse:  # noqa: E501
        """registerUsersToBracket  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_users_to_bracket_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: RegisterToBracketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfJoinLeagueResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the register_users_to_bracket_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.register_users_to_bracket_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def register_users_to_bracket_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[RegisterToBracketRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """registerUsersToBracket  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_users_to_bracket_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: RegisterToBracketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfJoinLeagueResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_users_to_bracket_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfJoinLeagueResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/user/{version}/add', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def remove_match_from_queue_using_get(self, authorization : StrictStr, league_match_id : Annotated[StrictInt, Field(..., description="leagueMatchId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> Wrapper:  # noqa: E501
        """removeMatchFromQueue  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_match_from_queue_using_get(authorization, league_match_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param league_match_id: leagueMatchId (required)
        :type league_match_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the remove_match_from_queue_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.remove_match_from_queue_using_get_with_http_info(authorization, league_match_id, version, **kwargs)  # noqa: E501

    @validate_arguments
    def remove_match_from_queue_using_get_with_http_info(self, authorization : StrictStr, league_match_id : Annotated[StrictInt, Field(..., description="leagueMatchId")], version : Annotated[StrictStr, Field(..., description="version")], **kwargs) -> ApiResponse:  # noqa: E501
        """removeMatchFromQueue  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_match_from_queue_using_get_with_http_info(authorization, league_match_id, version, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param league_match_id: leagueMatchId (required)
        :type league_match_id: int
        :param version: version (required)
        :type version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'league_match_id',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_match_from_queue_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['league_match_id']:
            _path_params['leagueMatchId'] = _params['league_match_id']

        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/match/{leagueMatchId}/queue/{version}/remove', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def save_bracket_using_put(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[BracketRequest, Field(..., description="request")], **kwargs) -> SingleWrapperOfLeagueResponse:  # noqa: E501
        """saveBracket  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.save_bracket_using_put(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: BracketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfLeagueResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the save_bracket_using_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.save_bracket_using_put_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def save_bracket_using_put_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[BracketRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """saveBracket  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.save_bracket_using_put_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: BracketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfLeagueResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_bracket_using_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfLeagueResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/save', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def save_match_seeding_using_post(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(MatchRoundReq), Field(..., description="request")], **kwargs) -> Wrapper:  # noqa: E501
        """saveMatchSeeding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.save_match_seeding_using_post(authorization, bracket_id, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[MatchRoundReq]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the save_match_seeding_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.save_match_seeding_using_post_with_http_info(authorization, bracket_id, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def save_match_seeding_using_post_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(MatchRoundReq), Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """saveMatchSeeding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.save_match_seeding_using_post_with_http_info(authorization, bracket_id, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[MatchRoundReq]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_match_seeding_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('bracket_id') is not None:  # noqa: E501
            _query_params.append(('bracketId', _params['bracket_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/seed', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def save_teams_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], create_new_team_request : Annotated[CreateNewTeamRequest, Field(..., description="createNewTeamRequest")], **kwargs) -> Wrapper:  # noqa: E501
        """saveTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.save_teams_using_post(authorization, version, create_new_team_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param create_new_team_request: createNewTeamRequest (required)
        :type create_new_team_request: CreateNewTeamRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Wrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the save_teams_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.save_teams_using_post_with_http_info(authorization, version, create_new_team_request, **kwargs)  # noqa: E501

    @validate_arguments
    def save_teams_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], create_new_team_request : Annotated[CreateNewTeamRequest, Field(..., description="createNewTeamRequest")], **kwargs) -> ApiResponse:  # noqa: E501
        """saveTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.save_teams_using_post_with_http_info(authorization, version, create_new_team_request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param create_new_team_request: createNewTeamRequest (required)
        :type create_new_team_request: CreateNewTeamRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Wrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'create_new_team_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_teams_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_new_team_request'] is not None:
            _body_params = _params['create_new_team_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Wrapper",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/{bracketId}/teams/{version}/save', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def seed_matches_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], type : Annotated[Optional[StrictStr], Field(description="type")] = None, **kwargs) -> ArrayWrapperOfMatchRound:  # noqa: E501
        """seedMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.seed_matches_using_get(authorization, bracket_id, version, type, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param type: type
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfMatchRound
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the seed_matches_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.seed_matches_using_get_with_http_info(authorization, bracket_id, version, type, **kwargs)  # noqa: E501

    @validate_arguments
    def seed_matches_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], version : Annotated[StrictStr, Field(..., description="version")], type : Annotated[Optional[StrictStr], Field(description="type")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """seedMatches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.seed_matches_using_get_with_http_info(authorization, bracket_id, version, type, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param version: version (required)
        :type version: str
        :param type: type
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfMatchRound, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'version',
            'type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method seed_matches_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('bracket_id') is not None:  # noqa: E501
            _query_params.append(('bracketId', _params['bracket_id']))

        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfMatchRound",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/{version}/seed', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def substitute_players_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(SubstitutePlayerRequest), Field(..., description="request")], **kwargs) -> SingleWrapperOfUnit:  # noqa: E501
        """substitutePlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.substitute_players_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[SubstitutePlayerRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfUnit
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the substitute_players_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.substitute_players_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def substitute_players_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(SubstitutePlayerRequest), Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """substitutePlayers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.substitute_players_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[SubstitutePlayerRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfUnit, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method substitute_players_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfUnit",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/participant/{version}/substitute', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def switch_player_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(SwitchBracketRequest), Field(..., description="request")], **kwargs) -> ArrayWrapperOfSwitchBracketResponse:  # noqa: E501
        """switchPlayer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.switch_player_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[SwitchBracketRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfSwitchBracketResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the switch_player_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.switch_player_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def switch_player_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(SwitchBracketRequest), Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """switchPlayer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.switch_player_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[SwitchBracketRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfSwitchBracketResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method switch_player_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfSwitchBracketResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/player/{version}/switch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def switch_teams_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(SwitchTeamRequest), Field(..., description="request")], **kwargs) -> ArrayWrapperOfSwitchBracketResponse:  # noqa: E501
        """switchTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.switch_teams_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[SwitchTeamRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArrayWrapperOfSwitchBracketResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the switch_teams_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.switch_teams_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def switch_teams_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(SwitchTeamRequest), Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """switchTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.switch_teams_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[SwitchTeamRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArrayWrapperOfSwitchBracketResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method switch_teams_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ArrayWrapperOfSwitchBracketResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/team/{version}/switch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def switch_wait_listed_teams_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(BracketPlayerSwitchWaitListedRequest), Field(..., description="request")], **kwargs) -> SingleWrapperOfUnit:  # noqa: E501
        """switchWaitListedTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.switch_wait_listed_teams_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[BracketPlayerSwitchWaitListedRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfUnit
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the switch_wait_listed_teams_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.switch_wait_listed_teams_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def switch_wait_listed_teams_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[conlist(BracketPlayerSwitchWaitListedRequest), Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """switchWaitListedTeams  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.switch_wait_listed_teams_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: List[BracketPlayerSwitchWaitListedRequest]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfUnit, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method switch_wait_listed_teams_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfUnit",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/teams/waitlist/{version}/update', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def switch_wait_listed_using_post(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[BracketPlayerSwitchWaitListedRequest, Field(..., description="request")], **kwargs) -> SingleWrapperOfUnit:  # noqa: E501
        """switchWaitListed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.switch_wait_listed_using_post(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: BracketPlayerSwitchWaitListedRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfUnit
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the switch_wait_listed_using_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.switch_wait_listed_using_post_with_http_info(authorization, version, request, **kwargs)  # noqa: E501

    @validate_arguments
    def switch_wait_listed_using_post_with_http_info(self, authorization : StrictStr, version : Annotated[StrictStr, Field(..., description="version")], request : Annotated[BracketPlayerSwitchWaitListedRequest, Field(..., description="request")], **kwargs) -> ApiResponse:  # noqa: E501
        """switchWaitListed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.switch_wait_listed_using_post_with_http_info(authorization, version, request, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param version: version (required)
        :type version: str
        :param request: request (required)
        :type request: BracketPlayerSwitchWaitListedRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfUnit, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'version',
            'request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method switch_wait_listed_using_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request'] is not None:
            _body_params = _params['request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfUnit",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/director/team/{version}/switchWaitlisted', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_bracket_approval_using_get(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], is_club_member : Annotated[StrictBool, Field(..., description="isClubMember")], registration_id : Annotated[StrictInt, Field(..., description="registrationId")], status : Annotated[StrictStr, Field(..., description="status")], version : Annotated[StrictStr, Field(..., description="version")], x_forwarded_for : Annotated[Optional[StrictStr], Field(description="x-forwarded-for")] = None, **kwargs) -> SingleWrapperOfSessionResponse:  # noqa: E501
        """updateBracketApproval  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_bracket_approval_using_get(authorization, bracket_id, is_club_member, registration_id, status, version, x_forwarded_for, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param is_club_member: isClubMember (required)
        :type is_club_member: bool
        :param registration_id: registrationId (required)
        :type registration_id: int
        :param status: status (required)
        :type status: str
        :param version: version (required)
        :type version: str
        :param x_forwarded_for: x-forwarded-for
        :type x_forwarded_for: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SingleWrapperOfSessionResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_bracket_approval_using_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_bracket_approval_using_get_with_http_info(authorization, bracket_id, is_club_member, registration_id, status, version, x_forwarded_for, **kwargs)  # noqa: E501

    @validate_arguments
    def update_bracket_approval_using_get_with_http_info(self, authorization : StrictStr, bracket_id : Annotated[StrictInt, Field(..., description="bracketId")], is_club_member : Annotated[StrictBool, Field(..., description="isClubMember")], registration_id : Annotated[StrictInt, Field(..., description="registrationId")], status : Annotated[StrictStr, Field(..., description="status")], version : Annotated[StrictStr, Field(..., description="version")], x_forwarded_for : Annotated[Optional[StrictStr], Field(description="x-forwarded-for")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """updateBracketApproval  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_bracket_approval_using_get_with_http_info(authorization, bracket_id, is_club_member, registration_id, status, version, x_forwarded_for, async_req=True)
        >>> result = thread.get()

        :param authorization: (required)
        :type authorization: str
        :param bracket_id: bracketId (required)
        :type bracket_id: int
        :param is_club_member: isClubMember (required)
        :type is_club_member: bool
        :param registration_id: registrationId (required)
        :type registration_id: int
        :param status: status (required)
        :type status: str
        :param version: version (required)
        :type version: str
        :param x_forwarded_for: x-forwarded-for
        :type x_forwarded_for: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SingleWrapperOfSessionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'bracket_id',
            'is_club_member',
            'registration_id',
            'status',
            'version',
            'x_forwarded_for'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bracket_approval_using_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['version']:
            _path_params['version'] = _params['version']


        # process the query parameters
        _query_params = []
        if _params.get('bracket_id') is not None:  # noqa: E501
            _query_params.append(('bracketId', _params['bracket_id']))

        if _params.get('is_club_member') is not None:  # noqa: E501
            _query_params.append(('isClubMember', _params['is_club_member']))

        if _params.get('registration_id') is not None:  # noqa: E501
            _query_params.append(('registrationId', _params['registration_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['x_forwarded_for']:
            _header_params['x-forwarded-for'] = _params['x_forwarded_for']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SingleWrapperOfSessionResponse",
            '403': None,
        }

        return self.api_client.call_api(
            '/brackets/approval/{version}/update', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
